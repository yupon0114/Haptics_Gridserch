# Haptics_Gridserch
空中音波ハプティクスの研究のためにラズベリーパイで使用したソフトウェアを保存するためのリポジトリです。  
研究室で開発したコードの保存のために作成しました。

*使用技術一覧(パイソンくらい)*  
<!-- 以下はシールド-->

 <img src="https://img.shields.io/badge/-Python-ffff00.svg?logo=python&style=popout"><img src="https://img.shields.io/badge/-Raspberrypi-C51A4A.svg?logo=raspberrypi&style=popout">
<img src="https://img.shields.io/badge/-Linux-FCC624.svg?logo=linux&style=plastic">
<img src="https://img.shields.io/badge/-Numpy-0000CD.svg?logo=Python&style=plastic">
<img src="https://img.shields.io/badge/-Github-181717.svg?logo=github&style=popout">
<img src="https://img.shields.io/badge/-Git-3cb371.svg?logo=git&style=popout-square">
<!--ここから説明-->

## このリポジトリの概要
2025年前期に作成したプログラムはラズベリーパイ上でDQN、PPOの2つの強化学習アルゴリズムを使用し、8つのスピーカーで出力した40kHzの超音波を一転に収束させることができる最適な位相を自動探索するプログラムでした。  
フィードバックを受ける部分にはラズベリーパイピコを使用し、USB(シリアルバス通信)を用いて電圧を文字としてラズパイに送信、その後文字を数字に変換して行っています。  

このリポジトリでは、2025年後期に取り組んだ内容を保存しています。  
後期では前期のシステムに加え、  
超音波距離センサーをToF(Time of Fry)で実装し、グリッドサーチを使用して超音波を収束させる対象物を三次元空間上で特定するシステムを作ります。
Raspi_GridSerchはラズベリーパイ4上で動作するプログラムです。Numpyのパッケージをダウンロードして使用しています。
pico_reflection_timeはラズベリーパイピコ上で動作するプログラムになります。picoのメイン関数に書き込んで使用しています。
speaker_moduleはラズベリーパイおよびピコで使用する関数や最初に行うGPIOピンの初期化処理などが入ったモジュールです。ラズベリーパイもラズパイピコもこちらを使用しています。実行するプログラムと同じディレクトリ（階層）にファイルが無いと使えません♘　　

### システムについての説明
ここに私が1年間かけて学んだこの研究を進めるためのラズパイの知識をまとめています。基本的なことは調べたりAIに聞けば出てくるので省いています。AIが書いてきたコードが1行1行何となく理解できるようになればあとは何とかなるので頑張ってください
*ラズパイ間の通信について*  
ラズパイとラズパイピコはusb接続したうえで、ラズベリーパイからピコへの通信はシリアルポート通信を使用しています。ラズパイ→ピコ　と　ピコ→ラズパイは手順が違うので気をつけてください。ほかにも方法はあるらしいですがこの1種類の方法しか使用していません  
まずプログラムの頭にportの設定を書きます。このコードは、Raspberry Pi から USB接続されたマイコン（例：Arduino、raspberrypi pico） とシリアル通信を行うために、接続ポートを指定し、通信速度とタイムアウトを設定してシリアルポートを開く処理です。
Raspberry Pi（Linux）では、USBシリアルデバイスは通常/dev/ttyACM0、/dev/ttyACM1のどちらかとして認識され、再起動でもう片方に勝手に変わります。try関数を使用し、例外処理を挟むことで設定に失敗したら自動でもう片方に設定します。

 try:
     port = '/dev/ttyACM0'
 except serial.serialutil.SerialException as e:
     port = '/dev/ttyACM1'
 # タイムアウトを設定して readline() が永久にブロックしないようにする
 ser = serial.Serial(port, 115200, timeout=0.5)

*データのやり取り*
ラズパイ→ピコはser.write(b"start\n")というコードで文字列を送信し、ピコ上で cmd = sys.stdin.readline().strip() を実行すると文字データとしてcmdという変数に"start"が代入され、ピコ上で文字列を受け取ることができる、という流れです。ちなみにwriteはlinuxのシステムコールの一種で、ハードウェアの機能を呼び出して使用していることになります。  
この際、ピコ上で実行しているsys.stdin.readline().strip()はラズベリーパイが何も送っていない状態で実行するとそこで止まります。待ちます。ファイル"pico_refletion_time"はその特性を使用して、ラズベリーパイが何か送ってきたら始める、という処理を一行で実装しています。ラズパイからは"start"を送信しています。 
なぜこのような処理をしているかというと、ラズパイpicoは起動している限り、mainに書き込まれたプログラムを無限に実行し続けます。ad9833から超音波波形を生成し続けた状態でFanctionGenerateの出力を切るとad9833か回路がぶち壊れるらしいので、ラズパイから指示がない限り超音波を出力しない、必要な時だけ超音波を出す設計になっています。

ピコ→ラズパイ  
実行例として、ピコでprint(192.54,189.76)を実行し、ラズパイで　line = ser.readline().decode().strip()　を実行すると文字データとして"192.54,189.76"が得られます。この際、ラズベリーパイが受け取れるのは一行ずつ、またプリントされた文字列の行先はいわゆるデータ保存におけるキュー構造になっており、ラズベリーパイはピコがプログラム実行中にprintした内容を古い順に1行ずつ読み取ります。つまりピコがデータを連続でprintし続ける場合(例えば測定した電圧など)、それを上回る速度でラズパイが読み取らないとどんどん処理するのが過去のデータにずれていきます。対処法として、ピコのデータ送信を上回る速度でラズパイが処理できるようにするか、ラズパイからコマンドが送られてきたらその時点の最新の測定データを一回だけ送信とするなどして私は回避しました。  
また一行しか読み取れない上に文字列なので、以下の箇所の様に、カンマ区切りで分割して変数に代入した後、数字にデータを変換して利用しています。また極端なデータが来たら再度データ取得待ちに戻ったり、エラーが起きやすいのでtry:を使用してエラーが起きても止まらないようにしています。よく思いついた自分。  　　

    print("start")
    ser.write(b"READ\n")
    while True:
        try:
            # 1行ずつ読み込み
            line = ser.readline().decode().strip()
            if not line:
                # データがまだ来ていなければ待機
                time.sleep(0.05)
                continue
            
            # 受信データの例: "12.34,56.78,34.56,78.90"
            # 文字列→数字の変換でエラーが起きすぎてtryに入ってるが多分もういらない
            try:
                values = [float(v) for v in line.split(',')]
                if len(values) == 4:
                    x1, x2, x3, x4 = values
                    print(f"Received: x1={x1}, x2={x2}, x3={x3}, x4={x4}")
                     # データの例: x1=12.34 x2=56.78 x3=34.56 x4=78.90
                     #↓はうまく測定できてないっぽい値が帰ってきたらその場で弾いている
                    if (1000 >= x1 >= 300 and 1000 >= x2 >= 300 and 1000 >= x3 >= 300 and 1000 >= x4 >= 300):
                        print("有効データ受信。測定開始")
                        break
                    break  # 1回受信したら終了（連続受信の場合は break を削除）
                else:
                    print("データ形式が不正:", line)
            except ValueError:
                print("データ変換エラー:", line)



長くなりそうなので気が向いたらQiitaかNoteにでも移そうかと思います。
それぞれのプログラムにはコメントをできるだけ入れているので読んでがんばってください。

githubを作るのに参考にしたサイト
https://zenn.dev/kd_gamegikenblg/articles/b220e23b0b7ef9

pythonなどのロゴ（シールド）やこのREADMEを作成するにあたって参考にしたサイト
https://qiita.com/shun198/items/c983c713452c041ef787#%E3%83%90%E3%83%83%E3%82%AF%E3%82%A8%E3%83%B3%E3%83%89%E8%A8%80%E8%AA%9E
